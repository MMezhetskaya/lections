# Lection 14

## DOM 

![Alt text](./dom.png "DOM, BOM и JS")
 
 - DOM-модель – это внутреннее представление HTML-страницы в виде дерева.
 - Все элементы страницы, включая теги, текст, комментарии, являются узлами DOM.
 - У элементов DOM есть свойства и методы, которые позволяют изменять их.
 
## SVG



## Canvas



## CSS графика


 
## BOM

BOM – это объекты для работы с чем угодно, кроме документа.

Например:

Объект **navigator** содержит общую информацию о браузере и операционной системе. Особенно примечательны два свойства:
 - navigator.userAgent – содержит информацию о браузере
 - navigator.platform – содержит информацию о платформе, позволяет различать Windows/Linux/Mac и т.п.
 
Объект **location** содержит информацию о текущем URL страницы и позволяет перенаправить посетителя на новый URL.

Функции **alert/confirm/prompt** – тоже входят в BOM.

Пример использования:

```javascript
alert( location.href ); // выведет текущий адрес
```

Большинство возможностей BOM стандартизированы в HTML 5, хотя различные браузеры и предоставляют зачастую что-то своё, в дополнение к стандарту.

## Сохранение данных на стороне клиента

- **Web Storage** – это прикладной программный интерфейс, определение которого первоначально было частью стандарта HTML5, но впоследствии было выделено в отдельную спецификацию. Эта спецификация все еще находится в стадии проекта, но частично (переносимым образом) реализована во всех текущих броузерах, включая IE8. Этот прикладной интерфейс содержит объекты localStorage и sessionStorage, которые, по сути, являются постоянно хранимыми ассоциативными массивами, отображающими ключи в строковые значения. Интерфейс Web Storage очень прост в использовании, он подходит для хранения больших (но не огромных) объемов данных и доступен во всех теку- щих броузерах, но не поддерживается старыми броузерами.

- **Cookies** – старейший механизм хранения данных на стороне клиента, который предназначен для использования серверными сценариями. В JS имеется довольно неудобный прикладной интерфейс, позволяющий управлять cookies на стороне клиента, но этот механизм сложен в использовании и подходит лишь для хранения небольших объемов текстовых данных. Кроме того, любые данные, хранящиеся в виде cookies, всегда передаются серверу с каждым HTTP-запросом, даже если эти данные представляют интерес только для клиента. Однако механизм cookies по-прежнему представляет определенный интерес для разработчиков клиентских сценариев, потому что он поддерживается всеми броузерами, старыми и новыми.

- **Session** - это хранилище данных в одном месте и передача связующего идентификатора в другое место. Тогда достаточно просто его послать и как будто переслал все данные (они берутся из хранилища). Выходит у второй стороны этих данных просто нет. 
Если нужен обоюдный доступ к данным - куки в руки! Можно, конечно, придумать много способов - от организации сессии в локальном хранилище, до прямого вшивания значений сессии в переменные JS.

- **IE User Data** - корпорация Microsoft реализовала в IE версии 5 и выше свой собственный механизм хранения данных на стороне клиента, известный как «userData». Механизм userData позволяет хранить достаточно большие объемы строковых данных и может использоваться как альтернатива механизму Web Storage в IE версии 7 и ниже.


- **Offline Web Applications** - стандарт HTML5 определяет прикладной программный интерфейс «Offline Web Applications» (автономные веб-приложения), позволяющий кэшировать веб-страницы и связанные с ними ресурсы (сценарии, CSS-файлы, изображения и т.д.). Это хранилище предназначено для сохранения веб-приложений целиком, а не только их данных, и позволяет веб-приложениям устанавливать себя, давая возможность использовать их даже при отсутствии соединения с Интернетом.

- **Базы данных для Веб** - разработчики, которым приходится работать с по-настоящему огромными объемами данных, предпочитают использовать базы данных, и многие производители начинают включать в свои броузеры функциональные возможности доступа к базам данных на стороне клиента. Броузеры Safari, Chrome и Opera включают прикладной интерфейс к базе данных SQL. Однако попытка стан- дартизации этого прикладного интерфейса потерпела неудачу, и весьма маловероятно, что он будет реализован в Firefox и IE. Существует альтернативный прикладной интерфейс доступа к базам данных, который был стандартизован под названием «Indexed Database API». Это прикладной интерфейс к простейшей объектной базе данных, не поддерживающей язык запросов. Оба прикладных интерфейса являются асинхронными и требуют использования обработчиков событий, что усложняет их использование.
 
- **Сохранность, безопасность и конфиденциальность** - веб-броузеры часто предлагают пользователям сохранить пароли и сохраняют их на диске в зашифрованном виде. Но ни один из механизмов хранения данных на стороне клиента, описываемый в выше, никак не связан с шифрованием: все, что вы будете сохранять, будет сохраняться на жестком диске в незашифрованном виде. То есть хранящиеся данные мо- гут быть извлечены чересчур любопытным пользователем, имеющим доступ к компьютеру, или злонамеренным программным обеспечением (на- пример, разнообразными шпионскими программами), находящимся на компьютере. По этой причине ни один из механизмов хранения данных на стороне клиента никогда не должен использоваться для хранения паролей, номеров банковских счетов или другой конфиденциальной информации. 

### Web Storage

Разница между localStorage и sessionStorage заключается лишь в сроке хранения и области видимости: они определяют, как долго будут храниться данные и кому они будут доступны.

#### LocalStorage

Объект localStorage представляет долговременное хранилище данных: срок хранения не ограничен, и данные сохраняются на компьютере пользователя, пока не будут удалены веб-приложением или пока пользователь не потребует от броузера (посредством некоторого пользовательского интерфейса, предоставляемого броузером) удалить их.

```javascript
localStorage.setItem("x", 1); 
localStorage.removeItem("x"); 
localStorage.clear(); 
```

#### SessionStorage

Данные, сохраняемые в sessionStorage, имеют другой срок хранения: они хранят-ся, пока остается открытым окно верхнего уровня или вкладка броузера, в которой выполнялся сценарий, сохранивший эти данные. При закрытии окна или вкладки все данные, хранящиеся в sessionStorage, удаляются. (Отметьте, однако, что современные броузеры имеют возможность повторно открывать недавно закрытые вкладки и восстанавливать последний сеанс работы с броузером, поэтому срок хранения информации об этих вкладках и связанных с ними хранилищах sessionStorage может оказаться больше, чем кажется.)

Доступность данных в хранилище sessionStorage, как и в хранилище localStorage, ограничивается происхождением документа, т. е. документы с разным происхождением никогда не смогут совместно использовать одни и те же данные в sessionStorage. Но помимо этого доступность данных в хранилище sessionStorage ограничивается также окном. Если пользователь откроет в броузере две вкладки, ото- бражающие документы с общим происхождением, эти две вкладки будут владеть разными хранилищами sessionStorage. Сценарий, выполняющийся в одной вкладке, не сможет прочитать или изменить данные, сохраненные в другой вкладке, даже если в обеих вкладках будет открыта одна и та же страница и будет выполняться один и тот же сценарий.

```javascript
sessionStorage.setItem("x", 1); 
sessionStorage.removeItem("x"); 
sessionStorage.clear(); 
```


### Cookie && Session

Помимо имени и значения каждый cookie имеет необязательные атрибуты, управляющие сроком его хранения и областью видимости. По умолчанию cookies их значения сохраняются на период сеанса веб-броузера и теряются при закрытии броузера.

Чтобы cookie сохранялся после окончания сеанса, необходимо сообщить броузеру, как долго (в секундах) он должен храниться, указав значение атрибута max­ age. Если указать срок хранения, броузер сохранит cookie в локальном файле и удалит его только по истечении срока хранения.

 - имя=значение;
 - max-age=число секунд;

Следующая функция устанавливает cookie с дополнительным атрибутом max-age:

```javascript
function setCookie(name, value, daysToLive) {
    var cookie = name + "=" + encodeURIComponent(value);
    
    if (typeof daysToLive === "number") {
        cookie += "; max-age=" + (daysToLive*60*60*24);
    }
    
    document.cookie = cookie;
}
```

 Аналогичным образом можно установить атрибуты path, domain и secure, дописав к значению cookie строки следующего формата перед его записью в свойство cookie:
 - path=путь;
 - domain=домен;
 - secure
 
Чтобы изменить значение cookie, установите его значение снова, указав то же имя, путь, домен и новое значение. При изменении значения cookie можно также переопределить срок его хранения, указав новое значение в атрибуте max-age.

Чтение cookie:

```javascript
function getCookies() {
    var cookies = {}; 
    var all = document.cookie;
    
    if (all === "") return cookies;
    
    var list = all.split("; "); 
    
    for(var i = 0; i < list.length; i++) { 
        var cookie = list[i];
        var p = cookie.indexOf("="); 
        var name = cookie.substring(0,p); 
        var value = cookie.substring(p+1); 
        
        value = decodeURIComponent(value); 
        cookies[name] = value;
    }
    
    return cookies;
}
```

Чтобы удалить cookie, установите его снова, указав то же имя, путь, домен и любое произвольное (возможно пустое) значение, а в атрибут max-age запишите 0.
 
По умолчанию cookie связывается с создавшей его веб-страницей и доступен этой странице, а также другим страницам из того же каталога или любых его подкаталогов. Если, например, веб-страница http://www.example.com/catalog/ index.html создаст cookie, то этот cookie будет также видим страницам http:// www.example.com/catalog/order.html и http://www.example.com/catalog/widgets/in­ dex.html, но невидим странице http://www.example.com/about.htm

Механизм сессий использует куки для хранения sessionid, и все. Разница банальна - куки на клиенте, сессия на сервере, следствия логичны - куки места на сервере не занимют, сессии недоступны для прямого чтения и изменения юзером. То есть в сессии вполне можно хранить пароль в открытом виде, например, хотя и не рекомендуется на всякий случай. Также размер куков ограничен, а в сессии вполне можно хранить довольно большие объемы данных, объекты и прочее.

Еще - сессия работает до закрытия браузера или до истечения серверного таймаута на хранение, куки можно поставить хоть на 10 лет. То есть, куки надо использовать для более долгих сроков (чекбокс "запомнить меня", например).

## HTTP + AJAX & COMET + NODE

Протокол передачи гипертекста (Hypertext Transfer Protocol, HTTP) определяет, как веб-броузеры должны запрашивать документы, как они должны передавать информацию веб-серверам и как веб-серверы должны отвечать на эти запросы и передачи.

Ajax – это аббревиатура от Asynchronous JavaScript and XML (асинхронный JavaScript и XML).

Термин Ajax описывает архитектуру веб-приложений, отличительной чертой которых является работа с протоколом HTTP. Ключевой особенностью Ajax-приложения является использование протокола HTTP для инициации обмена данными с веб-сервером без необходимости перезагружать страницу.

В некотором смысле архитектура Comet является обратной по отношению к Ajax: в архитектуре Comet не клиент, а сервер инициирует взаимодействие, асинхронно отсылая сообщения клиенту.

Можно сказать, что AJAX – это «отправил запрос – получил результат», а COMET – это «непрерывный канал, по которому приходят данные».

Примеры COMET-приложений:

```
Чат – человек сидит и смотрит, что пишут другие. При этом новые сообщения приходят «сами по себе», он не должен нажимать на кнопку для обновления окна чата.

Аукцион – человек смотрит на экран и видит, как обновляется текущая ставка за товар.

Интерфейс редактирования – когда один редактор начинает изменять документ, другие видят информацию об этом. Возможно и совместное редактирование, когда редакторы видят изменения друг друга.
```

На текущий момент технология COMET удобно реализуется во всех браузерах.

HTTP-запрос состоит из четырех частей:
 - метод HTTP-запроса или тип «операции»
 - запрашиваемый URL-адрес
 - необязательные заголовки запроса, которые могут включать информацию для аутентификации
 - необязательное тело запроса
 
HTTP-ответ, возвращаемый сервером, состоит из трех частей:
 - числовое и текстовое значение, определяющее код состояния, свидетельствующий об успехе или об ошибке
 - набор заголовков ответа
 - тело ответа

Технически, с помощью AJAX можно обмениваться любыми данными с сервером.

Обычно используются форматы:

 - **JSON** – для отправки и получения структурированных данных, объектов.
 - **XML** – если сервер почему-то работает в формате XML, то можно использовать и его, есть средства.
 - **HTML/текст** – можно и просто загрузить с сервера код HTML или текст для показа на странице.
 - **Бинарные данные, файлы** – гораздо реже, в современных браузерах есть удобные средства для них.”

### Node server

 1) mkdir myProject
 2) cd myProject
 3) npm install node-static
 4) mkdir server
 5) cd server
 6) touch server.js
```javascript
var http = require('http');
var static = require('node-static');
var file = new static.Server('.');

http.createServer(function(req, res) {
  file.serve(req, res);
}).listen(8080);

console.log('Server running on port 8080');
```
 7) node server/server.js
 8) http://127.0.0.1:8080/server/server.js
 
**Основные методы**

В функции accept используются два объекта:

 1) req – объект запроса («request»), то есть то, что прислал клиент (обычно браузер), из него читаем данные.
 2) res – объект ответа («response»), в него пишем данные в ответ клиенту.

```javascript
function accept(req, res) {

  res.writeHead(200, {
    'Content-Type': 'text/plain',
    'Cache-Control': 'no-cache'
  });

  res.end("OK");
}
```

вызов res.writeHead(HTTP-код, [строка статуса], {заголовки}) пишет заголовки.
вызов res.write(txt) пишет текст в ответ.
вызов res.end(txt) – завершает запрос ответом.

**Основы XMLHttpRequest**

Объект XMLHttpRequest (или, как его кратко называют, «XHR») дает возможность из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы.

Несмотря на слово «XML» в названии, XMLHttpRequest может работать с любыми данными, а не только с XML.

Использовать его очень просто.

Пример использования

Как правило, XMLHttpRequest используют для загрузки данных.

Для начала посмотрим на пример использования, который загружает файл phones.json из текущей директории и выдаёт его содержимое:

```javascript
// 1. Создаём новый объект XMLHttpRequest
var xhr = new XMLHttpRequest();

// 2. Конфигурируем его: GET-запрос на URL 'phones.json'
xhr.open('GET', 'action/test', true);

// 3. Отсылаем запрос
xhr.send();


xhr.onreadystatechange = function() {
  if (xhr.readyState != 4) return;

  document.body.innerHTML = 'Готово!';

  // 4. Если код ответа сервера не 200, то это ошибка
  if (xhr.status != 200) {
    // обработать ошибку
    console.log( xhr.status + ': ' + xhr.statusText ); // пример вывода: 404: Not Found
  } else {
    // вывести результат
    console.log( xhr.responseText ); // responseText -- текст ответа.
  }
}

document.body.innerHTML = 'Загрузка!';
```

**open**

xhr.open(method, URL, async, user, password)
Этот метод – как правило, вызывается первым после создания объекта XMLHttpRequest.

Задаёт основные параметры запроса:

 - method – HTTP-метод. Как правило, используется GET либо POST, хотя доступны и более экзотические, вроде 
TRACE/DELETE/PUT и т.п.

 - URL – адрес запроса. Можно использовать не только http/https, но и другие протоколы, например ftp:// и file://.

При этом есть ограничения безопасности, называемые «Same Origin Policy»: запрос со страницы можно отправлять только на тот же протокол://домен:порт, с которого она пришла.

 - async – если установлено в false, то запрос производится синхронно, если true – асинхронно.

«Синхронный запрос» означает, что после вызова xhr.send() и до ответа сервера главный поток будет «заморожен»: посетитель не сможет взаимодействовать со страницей – прокручивать, нажимать на кнопки и т.п. После получения ответа выполнение продолжится со следующей строки.

 - «Асинхронный запрос» означает, что браузер отправит запрос, а далее результат нужно будет получить через обработчики
  событий.

 - user, password – логин и пароль для HTTP-авторизации, если нужны.
 
**send**
 
 Синтаксис:
 
 - xhr.send([body])
 
 Именно этод метод открывает соединение и отправляет запрос на сервер.
 
 В body находится тело запроса. Не у всякого запроса есть тело, например у GET-запросов тела нет, а у POST – основные данные как раз передаются через body.
 
**abort**
 
 Вызов xhr.abort() прерывает выполнение запроса.
 
**status, statusText, responseText**
 
 Основные свойства, содержащие ответ сервера:
 
 - status
 
 HTTP-код ответа: 200, 404, 403 и так далее. Может быть также равен 0, если сервер не ответил или при запросе на другой домен.
 
 - statusText
 
 Текстовое описание статуса от сервера: OK, Not Found, Forbidden и так далее.
 
 - responseText
 
 Текст ответа сервера.
 Есть и ещё одно свойство, которое используется гораздо реже:
 
 - responseXML
 
 Если сервер вернул XML, снабдив его правильным заголовком Content-type: text/xml, то браузер создаст из него XML-документ. По нему можно будет делать запросы xhr.responseXml.querySelector("...") и другие.
 
 Оно используется редко, так как обычно используют не XML, а JSON. То есть, сервер возвращает JSON в виде текста, который браузер превращает в объект вызовом JSON.parse(xhr.responseText).
 
**Синхронные и асинхронные запросы**
 
 Если в методе open установить параметр async равным false, то запрос будет синхронным.
 
 Синхронные вызовы используются чрезвычайно редко, так как блокируют взаимодействие со страницей до окончания загрузки.

**Что стоит запомнить?**

1) GET передает данные серверу используя URL, когда POST передает данные, используя тело HTTP запроса.

2) Длина URL'а ограничена 1024 символами, это и будет верхним ограничением для данных, которые можно отослать GET'ом.

3) POST может отправлять гораздо большие объемы данных. Лимит устанавливается веб-сервером и обычно равен около 2MB.

4) Передача данных методом POST более безопасна, чем методом GET, так как секретные данные (например пароль) не отображаются напрямую в web-клиенте пользователя (в отличии от URL, который виден почти всегда).

GET ─ получить данные
PUT ─ создать данные
POST ─ редактировать данные
DELETE ─ удалить данные

С PUT и POST часто неразбериха, разные источники рекомендуют по разному ... на самом деле их обоих можно использовать для создания и редактирования, выбирать вам, разве что если один объект то PUT, несколько то POST. Не будет ошибкой использовать POST для одного объекта, это все скорее правила хорошего тона чем жесткие требования ─ встречал api где все было на GET запросах.

## ES5-6

Стандарт [ES-2015](http://www.ecma-international.org/publications/standards/Ecma-262.htm) был принят в июне 2015. Пока что большинство браузеров реализуют его частично, текущее состояние реализации различных возможностей можно посмотреть [здесь](https://kangax.github.io/compat-table/es6/).

Самое простое – это когда нужен один конкретный движок JS, например V8 (Chrome).

Тогда можно использовать только то, что поддерживается именно в нём. Заметим, что в V8 большинство возможностей ES-2015 поддерживаются только при включённом use strict.

При разработке на Node.JS обычно так и делают. Если же нужна кросс-браузерная поддержка, то этот вариант не подойдёт.

Babel.JS – это транспайлер, переписывающий код на ES-2015 в код на предыдущем стандарте ES5.

Он состоит из двух частей:

 1) cобственно транспайлер, который переписывает код.
 
 2) Полифилл, который добавляет методы.

[ES6 список фич](http://es6-features.org/#Constants)

## webpack + BABEL + SASS

По шагам:

 1) mkdir my_project 
 
 2) cd my_project
 
 3) npm init
 
 4) npm install --save-dev webpack
 
## Заключение

## ДЗ

## Справочники
- [ES6 список фич](http://es6-features.org/#Constants)
- [Ecma](http://www.ecma-international.org/publications/standards/Ecma-262.htm)