# Lection 14
 
## DOM 

![Alt text](./dom.png "DOM, BOM и JS")
 
 - DOM-модель – это внутреннее представление HTML-страницы в виде дерева.
 - Все элементы страницы, включая теги, текст, комментарии, являются узлами DOM.
 - У элементов DOM есть свойства и методы, которые позволяют изменять их.
 

## BOM

BOM – это объекты для работы с чем угодно, кроме документа.

Например:

Объект **navigator** содержит общую информацию о браузере и операционной системе. Особенно примечательны два свойства:
 - navigator.userAgent – содержит информацию о браузере
 - navigator.platform – содержит информацию о платформе, позволяет различать Windows/Linux/Mac и т.п.
 
Объект **location** содержит информацию о текущем URL страницы и позволяет перенаправить посетителя на новый URL.

Функции **alert/confirm/prompt** – тоже входят в BOM.

Пример использования:

```javascript
alert( location.href ); // выведет текущий адрес
```

Большинство возможностей BOM стандартизированы в HTML 5, хотя различные браузеры и предоставляют зачастую что-то своё, в дополнение к стандарту.

## Сохранение данных на стороне клиента

- **Web Storage** – это прикладной программный интерфейс, определение которого первоначально было частью стандарта HTML5, но впоследствии было выделено в отдельную спецификацию. Эта спецификация все еще находится в стадии проекта, но частично (переносимым образом) реализована во всех текущих броузерах, включая IE8. Этот прикладной интерфейс содержит объекты localStorage и sessionStorage, которые, по сути, являются постоянно хранимыми ассоциативными массивами, отображающими ключи в строковые значения. Интерфейс Web Storage очень прост в использовании, он подходит для хранения больших (но не огромных) объемов данных и доступен во всех теку- щих броузерах, но не поддерживается старыми броузерами.

- **Cookies** – старейший механизм хранения данных на стороне клиента, который предназначен для использования серверными сценариями. В JS имеется довольно неудобный прикладной интерфейс, позволяющий управлять cookies на стороне клиента, но этот механизм сложен в использовании и подходит лишь для хранения небольших объемов текстовых данных. Кроме того, любые данные, хранящиеся в виде cookies, всегда передаются серверу с каждым HTTP-запросом, даже если эти данные представляют интерес только для клиента. Однако механизм cookies по-прежнему представляет определенный интерес для разработчиков клиентских сценариев, потому что он поддерживается всеми броузерами, старыми и новыми.

- **Session** - это хранилище данных в одном месте и передача связующего идентификатора в другое место. Тогда достаточно просто его послать и как будто переслал все данные (они берутся из хранилища). Выходит у второй стороны этих данных просто нет. 
Если нужен обоюдный доступ к данным - куки в руки! Можно, конечно, придумать много способов - от организации сессии в локальном хранилище, до прямого вшивания значений сессии в переменные JS.

- **IE User Data** - корпорация Microsoft реализовала в IE версии 5 и выше свой собственный механизм хранения данных на стороне клиента, известный как «userData». Механизм userData позволяет хранить достаточно большие объемы строковых данных и может использоваться как альтернатива механизму Web Storage в IE версии 7 и ниже.


- **Offline Web Applications** - стандарт HTML5 определяет прикладной программный интерфейс «Offline Web Applications» (автономные веб-приложения), позволяющий кэшировать веб-страницы и связанные с ними ресурсы (сценарии, CSS-файлы, изображения и т.д.). Это хранилище предназначено для сохранения веб-приложений целиком, а не только их данных, и позволяет веб-приложениям устанавливать себя, давая возможность использовать их даже при отсутствии соединения с Интернетом.

- **Базы данных для Веб** - разработчики, которым приходится работать с по-настоящему огромными объемами данных, предпочитают использовать базы данных, и многие производители начинают включать в свои броузеры функциональные возможности доступа к базам данных на стороне клиента. Броузеры Safari, Chrome и Opera включают прикладной интерфейс к базе данных SQL. Однако попытка стан- дартизации этого прикладного интерфейса потерпела неудачу, и весьма маловероятно, что он будет реализован в Firefox и IE. Существует альтернативный прикладной интерфейс доступа к базам данных, который был стандартизован под названием «Indexed Database API». Это прикладной интерфейс к простейшей объектной базе данных, не поддерживающей язык запросов. Оба прикладных интерфейса являются асинхронными и требуют использования обработчиков событий, что усложняет их использование.
 
- **Сохранность, безопасность и конфиденциальность** - веб-броузеры часто предлагают пользователям сохранить пароли и сохраняют их на диске в зашифрованном виде. Но ни один из механизмов хранения данных на стороне клиента, описываемый в выше, никак не связан с шифрованием: все, что вы будете сохранять, будет сохраняться на жестком диске в незашифрованном виде. То есть хранящиеся данные мо- гут быть извлечены чересчур любопытным пользователем, имеющим доступ к компьютеру, или злонамеренным программным обеспечением (на- пример, разнообразными шпионскими программами), находящимся на компьютере. По этой причине ни один из механизмов хранения данных на стороне клиента никогда не должен использоваться для хранения паролей, номеров банковских счетов или другой конфиденциальной информации. 

### Web Storage

Разница между localStorage и sessionStorage заключается лишь в сроке хранения и области видимости: они определяют, как долго будут храниться данные и кому они будут доступны.

#### LocalStorage

Объект localStorage представляет долговременное хранилище данных: срок хранения не ограничен, и данные сохраняются на компьютере пользователя, пока не будут удалены веб-приложением или пока пользователь не потребует от броузера (посредством некоторого пользовательского интерфейса, предоставляемого броузером) удалить их.

```javascript
localStorage.setItem("x", 1); 
localStorage.removeItem("x"); 
localStorage.clear(); 
```

#### SessionStorage

Данные, сохраняемые в sessionStorage, имеют другой срок хранения: они хранят-ся, пока остается открытым окно верхнего уровня или вкладка броузера, в которой выполнялся сценарий, сохранивший эти данные. При закрытии окна или вкладки все данные, хранящиеся в sessionStorage, удаляются. (Отметьте, однако, что современные броузеры имеют возможность повторно открывать недавно закрытые вкладки и восстанавливать последний сеанс работы с броузером, поэтому срок хранения информации об этих вкладках и связанных с ними хранилищах sessionStorage может оказаться больше, чем кажется.)

Доступность данных в хранилище sessionStorage, как и в хранилище localStorage, ограничивается происхождением документа, т. е. документы с разным происхождением никогда не смогут совместно использовать одни и те же данные в sessionStorage. Но помимо этого доступность данных в хранилище sessionStorage ограничивается также окном. Если пользователь откроет в броузере две вкладки, ото- бражающие документы с общим происхождением, эти две вкладки будут владеть разными хранилищами sessionStorage. Сценарий, выполняющийся в одной вкладке, не сможет прочитать или изменить данные, сохраненные в другой вкладке, даже если в обеих вкладках будет открыта одна и та же страница и будет выполняться один и тот же сценарий.

```javascript
sessionStorage.setItem("x", 1); 
sessionStorage.removeItem("x"); 
sessionStorage.clear(); 
```


### Cookie && Session

Помимо имени и значения каждый cookie имеет необязательные атрибуты, управляющие сроком его хранения и областью видимости. По умолчанию cookies их значения сохраняются на период сеанса веб-броузера и теряются при закрытии броузера.

Чтобы cookie сохранялся после окончания сеанса, необходимо сообщить броузеру, как долго (в секундах) он должен храниться, указав значение атрибута max­ age. Если указать срок хранения, броузер сохранит cookie в локальном файле и удалит его только по истечении срока хранения.

 - имя=значение;
 - max-age=число секунд;

Следующая функция устанавливает cookie с дополнительным атрибутом max-age:

```javascript
function setCookie(name, value, daysToLive) {
    var cookie = name + "=" + encodeURIComponent(value);
    
    if (typeof daysToLive === "number") {
        cookie += "; max-age=" + (daysToLive*60*60*24);
    }
    
    document.cookie = cookie;
}
```

 Аналогичным образом можно установить атрибуты path, domain и secure, дописав к значению cookie строки следующего формата перед его записью в свойство cookie:
 - path=путь;
 - domain=домен;
 - secure
 
Чтобы изменить значение cookie, установите его значение снова, указав то же имя, путь, домен и новое значение. При изменении значения cookie можно также переопределить срок его хранения, указав новое значение в атрибуте max-age.

Чтение cookie:

```javascript
function getCookies() {
    var cookies = {}; 
    var all = document.cookie;
    
    if (all === "") return cookies;
    
    var list = all.split("; "); 
    
    for(var i = 0; i < list.length; i++) { 
        var cookie = list[i];
        var p = cookie.indexOf("="); 
        var name = cookie.substring(0,p); 
        var value = cookie.substring(p+1); 
        
        value = decodeURIComponent(value); 
        cookies[name] = value;
    }
    
    return cookies;
}
```

Чтобы удалить cookie, установите его снова, указав то же имя, путь, домен и любое произвольное (возможно пустое) значение, а в атрибут max-age запишите 0.
 
По умолчанию cookie связывается с создавшей его веб-страницей и доступен этой странице, а также другим страницам из того же каталога или любых его подкаталогов. Если, например, веб-страница http://www.example.com/catalog/ index.html создаст cookie, то этот cookie будет также видим страницам http:// www.example.com/catalog/order.html и http://www.example.com/catalog/widgets/in­ dex.html, но невидим странице http://www.example.com/about.htm

Механизм сессий использует куки для хранения sessionid, и все. Разница банальна - куки на клиенте, сессия на сервере, следствия логичны - куки места на сервере не занимют, сессии недоступны для прямого чтения и изменения юзером. То есть в сессии вполне можно хранить пароль в открытом виде, например, хотя и не рекомендуется на всякий случай. Также размер куков ограничен, а в сессии вполне можно хранить довольно большие объемы данных, объекты и прочее.

Еще - сессия работает до закрытия браузера или до истечения серверного таймаута на хранение, куки можно поставить хоть на 10 лет. То есть, куки надо использовать для более долгих сроков (чекбокс "запомнить меня", например).

## HTTP + AJAX & COMET

Протокол передачи гипертекста (Hypertext Transfer Protocol, HTTP) определяет, как веб-броузеры должны запрашивать документы, как они должны передавать информацию веб-серверам и как веб-серверы должны отвечать на эти запросы и передачи.

Ajax – это аббревиатура от Asynchronous JavaScript and XML (асинхронный JavaScript и XML).

Термин Ajax описывает архитектуру веб-приложений, отличительной чертой которых является работа с протоколом HTTP. Ключевой особенностью Ajax-приложения является использование протокола HTTP для инициации обмена данными с веб-сервером без необходимости перезагружать страницу.

В некотором смысле архитектура Comet является обратной по отношению к Ajax: в архитектуре Comet не клиент, а сервер инициирует взаимодействие, асинхронно отсылая сообщения клиенту.

HTTP-запрос состоит из четырех частей:
 - метод HTTP-запроса или тип «операции»
 - запрашиваемый URL-адрес
 - необязательные заголовки запроса, которые могут включать информацию для аутентификации
 - необязательное тело запроса
 
HTTP-ответ, возвращаемый сервером, состоит из трех частей:
 - числовое и текстовое значение, определяющее код состояния, свидетельствующий об успехе или об ошибке
 - набор заголовков ответа
 - тело ответа

 - SVG
 - Canvas
 - CSS графика
 - ES5-6
 - webpack + BABEL + SASS
 
### Заключение

### ДЗ