# Lection 14

## [Node](https://nodejs.org/en/)

- платформа, основанная на движке V8

    - превращающая **JavaScript** из узкоспециализированного языка в язык общего назначения

    - возможность **JavaScript** взаимодействовать с устройствами ввода-вывода через свой **API** (написанный на **C++**)

    - подключать другие внешние библиотеки, написанные на разных языках, обеспечивая вызовы к ним из **JavaScript** - кода

    - применяется преимущественно на сервере, выполняя роль веб-сервера

        - возможность разрабатывать на **Node.js** и десктопные оконные приложения (при помощи **NW.js**, **AppJS** или **Electron** для **Linux**, **Windows** и **Mac OS**)

        - программировать микроконтроллеры (например, **tessel** и **espruino**)

    - в основе лежит событийно-ориентированное и асинхронное(или реактивное) программирование с неблокирующим вводом/выводом(I/O)

### Node server

- установим **[NodeJS](https://nodejs.org/en/)**

- установим пакет для сервера

```bash
npm i node-static
```

- создаем **server.js**

```js
let http = require('http'),
    static = require('node-static'),
    file = new static.Server('.'),
    port = 8080;

http
    .createServer(
        (req, res) => {
            file.serve(req, res);

            res.writeHead(
                200,
                {
                    'Content-Type': 'text/html',
                    'Cache-Control': 'no-cache'
                }
            );

            res.write('<h1>Im Title</h1>');
            res.end('<p>OK</p>');
        }
    )
    .listen(
        port,
        e => {
            if (e) return console.error(e);

            console.info(`==> 🌎 Listening on port ${port}. Open up http://localhost:${port}/ in your browser.`);
        }
    );
```

- **req** – объект запроса ("request"), то есть то, что прислал клиент (обычно браузер), из него читаем данные

- **res** – объект ответа ("response"), в него пишем данные в ответ клиенту

    - **res.writeHead(HTTP-код, [строка статуса], {заголовки})** пишет заголовки

    - **res.write(txt)** - пишет текст в ответ

    - **res.end(txt)** – завершает запрос ответом

- **node server/server.js**

## HTTP

**Задача HTTP**

- как веб-браузеры должны запрашивать документы

- как они должны передавать информацию веб-серверам

- как веб-серверы должны отвечать на эти запросы и передачи

**HTTP** - запрос("request") состоит из:

- метод **HTTP**

- запрашиваемый **URL**

- необязательные заголовки запроса

- необязательное тело запроса

**HTTP** - ответ("response") состоит из:

- числовое и текстовое значение

    - определяющее код состояния

        - об успехе или об ошибке

- набор заголовков ответа

- тело ответа

### AJAX

Технически, с помощью **AJAX** можно обмениваться любыми данными с сервером

- клиент инициирует взаимодействие

    - асинхронно отсылая сообщения на сервер

- использование протокола **HTTP** без необходимости перезагружать страницу

**Формат данных**

- **JSON** – для отправки и получения структурированных данных, объектов

- **XML** – если сервер почему-то работает в формате **XML**, то можно использовать и его, есть средства

- **HTML/текст** – можно и просто загрузить с сервера код **HTML** или текст для показа на странице

- **Бинарные данные, файлы** – гораздо реже, в современных браузерах есть удобные средства для них

### COMET

- сервер инициирует взаимодействие, асинхронно отсылая сообщения клиенту

### XMLHttpRequest

```js
// 1. Создаём новый объект XMLHttpRequest
let xhr = new XMLHttpRequest(),
    res;

// 2. Конфигурируем его: GET-запрос на URL
xhr.open('GET', URL, true);

// 3. Отсылаем запрос
xhr.send();

xhr.onreadystatechange = function() {
    if (xhr.readyState !== 4) return;

    domNodeBlock.innerHTML = 'Готово!';

    // 4. Если код ответа сервера не 200, то это ошибка
    if (xhr.status !== 200) {
        // обработать ошибку
        res = `${xhr.status}: ${xhr.statusText}`;
    } else {
        // вывести результат
        res = xhr.responseText;
    }

    console.log(res);
};

domNodeBlock.innerHTML = 'Загрузка!';
```

**xhr.open(method, URL, async, user, password)**

- **method** – **HTTP**-метод. как правило, используется **GET** либо **POST**, хотя доступны и более экзотические, вроде
**TRACE/DELETE/PUT** и т.п.

- **URL** – адрес запроса. Можно использовать не только **http/https**, но и другие протоколы, например **ftp://** и **file://**

- **async** – если установлено в **false**, то запрос производится синхронно, если **true** – асинхронно.

- **user**, **password** – логин и пароль для **HTTP**-авторизации, если нужны.

**xhr.send([body])**

- открывает соединение и отправляет запрос на сервер.

- **body** тело запроса


**Что стоит запомнить?**

- **GET** передает данные серверу используя **URL**, когда **POST** передает данные, используя тело **HTTP** запроса

- длина **URL**'а ограничена **1024** символами, это и будет верхним ограничением для данных, которые можно отослать **GET**'ом

- **POST** может отправлять гораздо большие объемы данных. Лимит устанавливается веб-сервером и обычно равен около 2MB

- передача данных методом **POST** более безопасна, чем методом **GET**, так как секретные данные (например пароль) не отображаются напрямую в web-клиенте пользователя (в отличии от **URL**, который виден почти всегда).

**GET** ─ получить данные

**PUT** ─ создать данные

**POST** ─ редактировать данные

**DELETE** ─ удалить данные

### [fetch](https://fetch.spec.whatwg.org/)

- "+"

    - улучшенный интерфейс для осуществления запросов к серверу

- "-"

    - поддержка в браузерах пока не очень распространена

```js
let promise = fetch(url[, options]);
```

- **url**

- **options**

    - **method** – метод запроса

    - **headers** – заголовки запроса (объект)

    - **body** – тело запроса: FormData, Blob, строка и т.п.

    - **mode** – одно из: "same-origin", "no-cors", "cors", указывает, в каком режиме кросс-доменности предполагается делать
запрос

    - **credentials** – одно из: "omit", "same-origin", "include", указывает, пересылать ли куки и заголовки авторизации
вместе с запросом

    - **cache** – одно из "default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached", указывает, как
кешировать запрос

    - **redirect** – можно поставить "follow" для обычного поведения при коде 30x (следовать редиректу) или "error" для интерпретации редиректа как ошибки

```js
fetch('/action_url')
    //проанализировать ответ и, если он нас устроит – вернуть промис с нужным форматом
    .then(function(response) {
        console.log(response.headers.get('Content-Type'));
        console.log(response.status);

        return response.json();
    })
    //полный ответ сервера
    .then(function(data) {
        console.log(data); //
    })
    .catch( alert );
```


```js
let resData = fetch('./action/data.json')
    .then(res => {
        return res.json();
    })
    .then(function(data) {
        return data;
    })
    .catch(alert);
```

## Автоматизация рабочих процессов

### [Gulp](https://gulpjs.com/)

- [Сборщик Gulp](https://github.com/Zlodej43sm/frontend__worker__gulp)

### [Webpack](https://webpack.js.org)

- [Сборщик Webpack](https://github.com/Zlodej43sm/frontend__worker__webpack)

## Концепция WEB

![DOM, BOM и JS](./dom.png "DOM, BOM и JS")

### DOM 
 
- **DOM** модель – это внутреннее представление **HTML**-страницы в виде дерева
 
- Все элементы страницы, включая теги, текст, комментарии, являются узлами **DOM**
 
- У элементов **DOM** есть свойства и методы, которые позволяют изменять их

### BOM

- **BOM** – это объекты для работы с чем угодно, кроме документа

```js
navigator;

location;

alert('Ololo'); //alert/confirm/prompt
```

**Тсссс!!!***

Большинство возможностей **BOM** стандартизированы в **HTML5**

### JS

- интерпретируемый 

- один поток

- динамическая типизация

- **event loop**

- зависит от среды выполнения браузер/сервер

- контекст браузер 
    
    - работа с **DOM**, **BOM** как со встроеннными типами, методами и свойствами 
    
- контекст сервер/стиральная машинка и тд
    
    - работа с ...

## Сохранение данных на стороне клиента

- **Web Storage**

- **Cookies**

- **Session**

- **Offline Web Applications** 

> Offline Web Applications - стандарт HTML5 определяет прикладной программный интерфейс "Offline Web Applications" (автономные веб-приложения), позволяющий кэшировать веб-страницы и связанные с ними ресурсы (сценарии, CSS-файлы, изображения и т.д.). Это хранилище предназначено для сохранения веб-приложений целиком, а не только их данных, и позволяет веб-приложениям устанавливать себя, давая возможность использовать их даже при отсутствии соединения с Интернетом.

- **Сохранность, безопасность и конфиденциальность** 

> Сохранность, безопасность и конфиденциальность - веб-браузеры часто предлагают пользователям сохранить пароли и сохраняют их на диске в зашифрованном виде. Но ни один из механизмов хранения данных на стороне клиента, описываемый в выше, никак не связан с шифрованием: все, что вы будете сохранять, будет сохраняться на жестком диске в незашифрованном виде. То есть хранящиеся данные могут быть извлечены чересчур любопытным пользователем, имеющим доступ к компьютеру, или злонамеренным программным обеспечением (например, разнообразными шпионскими программами), находящимся на компьютере. По этой причине ни один из механизмов хранения данных на стороне клиента никогда не должен использоваться для хранения паролей, номеров банковских счетов или другой конфиденциальной информации. 

## Web Storage

> Web Storage – это прикладной программный интерфейс, определение которого первоначально было частью стандарта HTML5, но впоследствии было выделено в отдельную спецификацию. Эта спецификация все еще находится в стадии проекта, но частично (переносимым образом) реализована во всех текущих браузерах, включая IE8. Этот прикладной интерфейс содержит объекты localStorage и sessionStorage, которые, по сути, являются постоянно хранимыми ассоциативными массивами, отображающими ключи в строковые значения. Интерфейс Web Storage очень прост в использовании, он подходит для хранения больших (но не огромных) объемов данных и доступен во всех текущих браузерах, но не поддерживается старыми браузерами.

**localStorage** vs **sessionStorage** 

- срок хранения 
 
- области видимости

&nbsp; | **localStorage** | **sessionStorage**
--- | --- | ---
**срок хранения** | не ограничен |  пока остается открытым окно верхнего уровня или вкладка браузера, в которой выполнялся сценарий, сохранивший эти данные
**области видимости** | ограничивается происхождением документа | ограничивается происхождением документа

### LocalStorage

```js
localStorage.setItem("x", 1); 
localStorage.removeItem("x"); 
localStorage.clear(); 
```

### SessionStorage

```js
sessionStorage.setItem("x", 1); 
sessionStorage.removeItem("x"); 
sessionStorage.clear(); 
```


## Cookie

> Cookies – старейший механизм хранения данных на стороне клиента, который предназначен для использования серверными сценариями. В JS имеется довольно неудобный прикладной интерфейс, позволяющий управлять cookies на стороне клиента, но этот механизм сложен в использовании и подходит лишь для хранения небольших объемов текстовых данных. Кроме того, любые данные, хранящиеся в виде cookies, всегда передаются серверу с каждым HTTP-запросом, даже если эти данные представляют интерес только для клиента. Однако механизм cookies по-прежнему представляет определенный интерес для разработчиков клиентских сценариев, потому что он поддерживается всеми браузерами, старыми и новыми.

- `имя=значение`
 
- по умолчанию **cookies** их значения сохраняются на период сеанса веб-браузера

- `max-age=число секунд`

**Установить cookies**

```js
//устанавливаем cookie с дополнительным атрибутом max-age:
function setCookie(name, value, daysToLive) {
    var cookie = name + "=" + encodeURIComponent(value);
    
    if (typeof daysToLive === "number") {
        cookie += "; max-age=" + (daysToLive*60*60*24);
    }
    
    document.cookie = cookie;
}
```

**Дополнительные атрибуты**

 - `path=путь`
 
 - `domain=домен`
 
 - `secure`

**Чтение cookie**

```js
//чтение cookie:
function getCookies() {
    var all = document.cookie,
        list;
    
    if (all === "") return {};
    
    list = all.split("; "); 
    
    return list.reduce(function(cookies, item) {
        var p = item.indexOf("="),
            name = item.substring(0, p),
            value = item.substring(p + 1); 
        
        cookies[name] = decodeURIComponent(value);
        
        return cookies;
    }, {});
}
```

**Удаление cookie**

- пустое значение

- `max-age=0`
 
*По умолчанию **cookie** связывается с создавшей его веб-страницей и доступен этой странице, а также другим страницам из того же каталога или любых его подкаталогов.

```
 http://www.example.com/catalog/ -> http://www.example.com/catalog/item - да
 http://www.example.com/catalog/ -> http://www.example.com/about - нет
```
 
### Session

> Session - это хранилище данных в одном месте и передача связующего идентификатора в другое место. Тогда достаточно просто его послать и как будто переслал все данные (они берутся из хранилища). Выходит у второй стороны этих данных просто нет.
Если нужен обоюдный доступ к данным - куки в руки! Можно, конечно, придумать много способов - от организации сессии в локальном хранилище, до прямого вшивания значений сессии в переменные JS.

- механизм сессий использует куки для хранения **sessionid**, и все
 
- разница банальна - куки на клиенте, сессия на сервере, 

- следствия логичны - куки места на сервере не занимют

- сессии недоступны для прямого чтения и изменения юзером, итого:
 
    - в сессии вполне можно хранить пароль в открытом виде, например, хотя и не рекомендуется на всякий случай
    
    - размер куков ограничен, а в сессии вполне можно хранить довольно большие объемы данных, объекты и прочее.
 
- сессия работает до закрытия браузера или до истечения серверного таймаута на хранение(куки можно поставить хоть на 10 лет), итого:
  
    -  куки надо использовать для более долгих сроков (чекбокс "запомнить меня", например)

## Заключение

- NODE

- HTTP

- Автоматизация рабочих процессов

- Концепция WEB

- Сохранение данных на стороне клиента


## ДЗ

## Справочники

- [NodeJS](https://nodejs.org/en/)

- [NodeJS, wiki](https://ru.wikipedia.org/wiki/Node.js)

- [Gulp](https://gulpjs.com/)

- [Сборщик Gulp](https://github.com/Zlodej43sm/frontend__worker__gulp)

- [Webpack](https://webpack.js.org)

- [Сборщик Webpack](https://github.com/Zlodej43sm/frontend__worker__webpack)

- [Ecma](http://www.ecma-international.org/publications/standards/Ecma-262.htm)

- [fetch](https://fetch.spec.whatwg.org/)