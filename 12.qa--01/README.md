# Lection 12

## Unit тестирование

**Делали ли вы хоть раз интеграционное тестирование?**

- да, проверяете, соответствует ли полученный результат вашим ожиданиям

**Цели интеграционного тестирования**

- проверяет, что несколько компонентов системы работают вместе правильно

- выполняет свою задачу, проверяет результат, но сложно для автоматизации

**Как это не все?**

>**Модульное тестирование**, или **юнит-тестирование** (англ. **unit testing**) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы. **@Wiki**

**Идея**

- писать тесты для каждой нетривиальной функции или метода

**Что даст?**

- быстро проверить, не привело ли очередное изменение кода к **регрессии**, то есть к появлению ошибок в уже оттестированных местах программы

- облегчает обнаружение и устранение ошибок вызванных регрессией

**Юнит-тестирование** – это первый бастион на борьбе с багами, за ним

- интеграционное

- приемочное

- ручное тестирование

![testing cycle](./test--00.jpg "testing cycle")

**Нужно ли все это вам?**

- не всегда

## Цели тестирования

### Наш метод тестирования

- **Что знаем о функции?**

    - что делает

    - что выдаёт

- **Как проверяем?**

    - в процессе разработки

- **Минусы**

    – легко его "недотестировать"

**Пример**

- пишем функцию `foo()`

- написали

    - тестируем с разными аргументам

        - `foo(a)` работает

        - `foo(b)` не работает

    - поправили код

        - стало работать `f(b)`

    - забыли заново протестировать `f(a)`

        - упс, вот и возможная ошибка в коде

>Автоматизированное тестирование – это когда тесты написаны отдельно от кода, и можно в любой момент запустить их и проверить все важные случаи использования.

## Не нужно писать тесты, если?

- делаем простой сайт-визитку

- логики нет, только представление

- делаем промо проект

- всегда пишете код без ошибок

    - обладаете идеальной памятью и даром предвидения

    - код настолько крут, что изменяет себя сам, вслед за требованиями клиента

    - иногда код объясняет клиенту, что его требования — не нужно реализовывать

![Alt text](./test--01.jpg "No need test")

**Вывод**

Любой долгосрочный проект без надлежащего покрытия тестами обречен рано или поздно быть переписанным с нуля

![Alt text](./test--02.png "No need test")

## Как нужно писать тесты?

Для того чтобы темная сторона кода не взяла верх, нужно придерживаться следующих основных правил

- легко поддерживаются

- легко читаются

- простые для понимания

- единая конвенция именования

- запускаются регулярно в автоматическом режиме

## TDD техника

**Test driven development** подразумевает, что перед написанием кода необходимо:

- создать тест, который будет тестировать несуществующий код, тест соответственно не пройдет

- написать код и убедиться, что тест прошел

- почистить код(рефакторинг)

- повторить

![Alt text](./test--03.png "TDD").

## BDD техника

**Behavior driven development** - это

- тесты

- документация

- примеры использования

**Поток разработки таков:**

- пишется спецификация, которая описывает самый базовый функционал

- делается начальная реализация

- для проверки соответствия спецификации мы задействуем фреймворк (в нашем случае **Mocha**)

    - запускает все тесты `it` и выводит ошибки, если они возникнут

        - при ошибках вносятся исправления

- спецификация расширяется

- идём на пункт -> начальная реализация

**Разработка pow: спецификация**

- хотим разработать функцию `pow(x, n)`, которая возводит x в целую степень `n`, для простоты `n >= 0`

- до разработки мы можем представить себе, что эта функция будет делать, и описать это по методике **BDD**

Описание называется спецификация, выглядит так:

```js
describe("pow", function() {
    it("возводит в n-ю степень", function() {
        assert.equal(pow(2, 3), 8);
    });
});
```

**У спецификации есть три основных строительных блока**

- **describe(название, function() { ... })** - что именно мы описываем, используется для группировки – блоков `it`

**it(название, function() { ... })** - в названии блока `it` человеческим языком описывается, что должна делать функция, далее следует тест, который проверяет это

**assert.equal(value1, value2)** - код внутри `it`, если реализация верна, должен выполняться без ошибок

**Пример в действии**
   
Мы будем использовать:
   
[Mocha](http://mochajs.org/) – эта библиотека содержит общие функции для тестирования, включая `describe` и `it`

[Chai](http://chaijs.com/) – библиотека поддерживает разнообразные функции для проверок

*библиотеки позволяют тестировать JS не только в браузере, но и на сервере **Node.JS**

- есть два варианта организации кода

```js
describe("pow", function() {
    it("возводит в n-ю степень", function() {
        assert.equal(pow(2, 3), 8);
        assert.equal(pow(3, 4), 81);
    });
});
```

```js
it("при возведении 2 в 3ю степень результат 8", function() {
    assert.equal(pow(2, 3), 8);
});

it("при возведении 3 в 4ю степень равен 81", function() {
    assert.equal(pow(3, 4), 81);
});
```

Чтобы быть уверенными, что функция работает верно, желательно протестировать её на большем количестве значений.

- вместо того, чтобы писать блоки `it` вручную, мы можем сгенерировать тесты в цикле `for`

```js
describe("pow", function() {
    function makeTest(x) {
        var expected = x * x * x;

        it("при возведении " + x + " в степень 3 результат: " + expected, function() {
            assert.equal(pow(x, 3), expected);
        });
    }

    for (var x = 1; x <= 5; x++) {
        makeTest(x);
    }
});
```

### Варианты assert

Самые востребованные **assert**-проверки, встроенные в **Chai**:

 - `assert(value)` – проверяет что value является true в логическом контексте

 - `assert.equal(value1, value2)` – проверяет равенство `value1 == value2`

 - `assert.strictEqual(value1, value2)` – проверяет строгое равенство `value1 === value2`

 - `assert.notEqual, assert.notStrictEqual` – проверки, обратные двум предыдущим

 - `assert.isTrue(value)` – проверяет, что `value === true`

 - `assert.isFalse(value)` – проверяет, что `value === false`

 *более полный список – в документации

**Зачем все это:**

- тесты, которые гарантируют правильность работы кода

- документация по функции, что она конкретно делает

- примеры использования функции, которые демонстрируют её работу внутри `it`

## TDD vs BDD

**BDD** — это попытка сформулировать лучшие практики **TDD**


## Заключение

## ДЗ


## Справочники
- [Mocha](http://mochajs.org/)
- [Chai](http://chaijs.com/)